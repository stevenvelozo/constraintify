(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c){ return c(i,!0); }if(u){ return u(i,!0); }var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++){ o(t[i]); }return o}return r})()({1:[function(require,module,exports){
/**
* @license MIT
* @author <steven@velozo.com>
*/

/**
* Constraintify browser shim loader
*/

// Load the constraintify module into the browser global automatically.
var libConstraintify = require('./Constraintify.js');

if (typeof(window) === 'object')
    { window.Constraintify = libConstraintify; }

module.exports = libConstraintify;
},{"./Constraintify.js":3}],2:[function(require,module,exports){
/**
* @license MIT
* @author <steven@velozo.com>
*/

/**
* Constraintify Logging
*
* @class ConstraintifyLog
*/

var ConstraintifyLog = function ConstraintifyLog(pSettings)
{
	this._Settings = pSettings;
};

ConstraintifyLog.prototype.writeConsole = function writeConsole (pLevel, pMessage, pObject)
{
	// Write the message
	console.log('['+pLevel+'] '+pMessage);

	// Write out the object if it is passed in
	if (typeof(pObject) !== 'undefined')
	{
		console.log(JSON.stringify(pObject, null, 4));
	}
};

ConstraintifyLog.prototype.trace = function trace (pMessage, pObject)
{
	this.writeConsole('TRACE', pMessage, pObject);
};

ConstraintifyLog.prototype.debug = function debug (pMessage, pObject)
{
	this.writeConsole('DEBUG', pMessage, pObject);
};

ConstraintifyLog.prototype.info = function info (pMessage, pObject)
{
	this.writeConsole('INFO', pMessage, pObject);
};

ConstraintifyLog.prototype.warning = function warning (pMessage, pObject)
{
	this.writeConsole('WARNING', pMessage, pObject);
};

ConstraintifyLog.prototype.error = function error (pMessage, pObject)
{
	this.writeConsole('ERROR', pMessage, pObject);
};


// Log the current date and time, well formatted (with Moment-Timezone)
ConstraintifyLog.prototype.logTime = function logTime (pMessage)
{
	var tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';
	var tmpDate = new Date();

	this.info(tmpMessage+': '+tmpDate.toString())
};

// Get a timestamp 
ConstraintifyLog.prototype.getTimeStamp = function getTimeStamp ()
{
	return +new Date();
};

ConstraintifyLog.prototype.getTimeDelta = function getTimeDelta (pTimeStamp)
{
	var tmpEndTime = +new Date();
	return tmpEndTime-pTimeStamp;
};

// Log the delta between a timestamp, and now with a message
ConstraintifyLog.prototype.logTimeDelta = function logTimeDelta (pTimeStamp, pMessage)
{
	var tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';

	var tmpEndTime = +new Date();
	var tmpOperationTime = tmpEndTime-pTimeStamp;

	this.info(tmpMessage +' ('+tmpOperationTime+'ms)');
};

module.exports = ConstraintifyLog;
},{}],3:[function(require,module,exports){
/**
* @license MIT
* @author <steven@velozo.com>
*/

/**
* Constraintify Graph Traversal Library
*
* @class Constraintify
*/
var Constraintify = function Constraintify(pSettings)
{
	this._Dependencies = {};

	this._Settings = (typeof(pSettings) === 'object') ? pSettings : (
		{
			// If this is true, show a whole lotta logs
			DebugLog: true,
			DebugLogNoisy: false
		});

	// This has behaviors similar to bunyan, for consistency
	this.log = new (require('./Constraintify-Log.js'))(this._Settings);

	this.Sets = {};
};

Constraintify.prototype.addSet = function addSet (pSetName)
{
	if (this.Sets.hasOwnProperty(pSetName))
	{
		if (this._Settings.DebugLogNoisy) { this.log.warning('Attempted to add set ['+pSetName+'] but it already exists.'); }
		return false;
	}
	if (this._Settings.DebugLog) { this.log.info('Adding set ['+pSetName+'].'); }

	this.Sets[pSetName] = {};
	return true;
};

Constraintify.prototype.addSetValue = function addSetValue (pSetName, pValue)
{
	if(!this.Sets.hasOwnProperty(pSetName))
	{
		if (this._Settings.DebugLog) { this.log.warning('Attempted to add value ['+pValue+'] to set ['+pSetName+'] but set does not exist.  Adding set now.'); }
		this.addSet(pSetName);
	}

	if (this.Sets[pSetName].hasOwnProperty(pValue))
	{
		if (this._Settings.DebugLogNoisy) { this.log.warning('Attempted to add DUPLICATE value ['+pValue+'] to set ['+pSetName+'] but value is already in set.'); }
		return false;
	}

	if (this._Settings.DebugLog) { this.log.info('Adding value ['+pValue+'] to set ['+pSetName+'].'); }
	this.Sets[pSetName][pValue] = {};
};

Constraintify.prototype.addSetConnection = function addSetConnection (pSetName, pValue, pConnectedSet)
{
	this.addSetValue(pSetName, pValue);

	if (this.Sets[pSetName][pValue].hasOwnProperty(pConnectedSet))
	{
		if (this._Settings.DebugLogNoisy) { this.log.info('Set ['+pSetName+']->['+pValue+'] already connected to set ['+pConnectedSet+'].'); }
		return false;
	}

	if (this._Settings.DebugLog) { this.log.info('Connecting Set ['+pSetName+']->['+pValue+'] to set ['+pConnectedSet+'].'); }
	this.Sets[pSetName][pValue][pConnectedSet] = {};
};

Constraintify.prototype.connectSetValue = function connectSetValue (pLeftSetName, pLeftValue, pRightSetName, pRightValue)
{
	this.addSet(pLeftSetName);
	this.addSet(pRightSetName);
	this.addSetValue(pLeftSetName, pLeftValue);
	this.addSetValue(pRightSetName, pRightValue);
	this.addSetConnection(pLeftSetName, pLeftValue, pRightSetName);

	this.Sets[pLeftSetName][pLeftValue][pRightSetName][pRightValue] = true;
};

Constraintify.prototype.addSetValueConnection = function addSetValueConnection (pLeftSetName, pLeftValue, pRightSetName, pRightValue)
{
	this.addSet(pLeftSetName);
	this.addSet(pRightSetName);

	this.addSetValue(pLeftSetName, pLeftValue);
	this.addSetValue(pRightSetName, pRightValue);

	this.connectSetValue(pLeftSetName, pLeftValue, pRightSetName, pRightValue);
};

Constraintify.prototype.addSetValueConnectionBidirectional = function addSetValueConnectionBidirectional (pLeftSetName, pLeftValue, pRightSetName, pRightValue)
{
	this.addSetValueConnection(pLeftSetName, pLeftValue, pRightSetName, pRightValue);
	this.addSetValueConnection(pRightSetName, pRightValue, pLeftSetName, pLeftValue);
};

Constraintify.prototype.getSetValues = function getSetValues (pLeftSetName)
{
	// If the set doesn't exist, return empty
	if (!this.Sets.hasOwnProperty(pLeftSetName))
	{
		return [];
	}
	return Object.keys(this.Sets[pLeftSetName]);
};

Constraintify.prototype.getSetConnectedValues = function getSetConnectedValues (pLeftSetName, pLeftValue, pRightSetName)
{
	// If the set doesn't exist, return empty
	if (!this.Sets.hasOwnProperty(pLeftSetName))
	{
		return [];
	}
	// If this value isn't in the set return empty.
	if (!this.Sets[pLeftSetName].hasOwnProperty(pLeftValue))
	{
		return [];
	}
	// If this value isn't connected to the right set return empty.
	if (!this.Sets[pLeftSetName][pLeftValue].hasOwnProperty(pRightSetName))
	{
		return [];
	}
	return Object.keys(this.Sets[pLeftSetName][pLeftValue][pRightSetName]);
};

Constraintify.prototype.checkSetValue = function checkSetValue (pLeftSetName, pLeftValue)
{
	if (!this.Sets.hasOwnProperty(pLeftSetName))
		{ return false; }
	return this.Sets[pLeftSetName].hasOwnProperty(pLeftValue);
};

Constraintify.prototype.checkSetConnectedValue = function checkSetConnectedValue (pLeftSetName, pLeftValue, pRightSetName, pRightSetValue)
{
	// If the set doesn't exist, return false
	if (!this.Sets.hasOwnProperty(pLeftSetName))
		{ return false; }
	// If this value isn't in the set return false.
	if (!this.Sets[pLeftSetName].hasOwnProperty(pLeftValue))
		{ return false; }
	// If this value isn't connected to the right set return false.
	if (!this.Sets[pLeftSetName][pLeftValue].hasOwnProperty(pRightSetName))
		{ return false; }
	return this.Sets[pLeftSetName][pLeftValue][pRightSetName].hasOwnProperty(pRightSetValue);
};;

module.exports = Constraintify;
},{"./Constraintify-Log.js":2}]},{},[1])


//# sourceMappingURL=constraintify.min.js.map
